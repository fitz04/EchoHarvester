{% extends "base.html" %}

{% block title %}Transcribe - EchoHarvester{% endblock %}
{% block nav_transcribe %}bg-indigo-700{% endblock %}

{% block head %}
<style>
    .segment-chip {
        min-width: 28px;
        height: 28px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: white;
        font-weight: 600;
    }
    .segment-chip:hover { opacity: 0.8; transform: scale(1.1); }
    .segment-chip.active { ring: 2px; box-shadow: 0 0 0 2px #4f46e5; }
    .strip-scroll { overflow-x: auto; scrollbar-width: thin; }
    .strip-scroll::-webkit-scrollbar { height: 6px; }
    .strip-scroll::-webkit-scrollbar-thumb { background: #c7d2fe; border-radius: 3px; }
</style>
{% endblock %}

{% block content %}
<div x-data="transcribePage()" x-init="init()" @keydown.window="handleKeydown($event)" class="flex h-[calc(100vh-12rem)] gap-4">

    <!-- Left Sidebar: Media List -->
    <div class="w-72 flex-shrink-0 bg-white rounded-lg shadow overflow-hidden flex flex-col" x-show="sidebarOpen">
        <div class="px-4 py-3 border-b border-gray-200 flex justify-between items-center">
            <h2 class="font-semibold text-gray-800 text-sm">Media</h2>
            <button @click="sidebarOpen = false" class="text-gray-400 hover:text-gray-600">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7"/>
                </svg>
            </button>
        </div>
        <div class="overflow-y-auto flex-1">
            <template x-for="media in mediaList" :key="media.id">
                <div @click="selectMedia(media.id)"
                    class="px-4 py-3 border-b border-gray-100 cursor-pointer hover:bg-gray-50 transition"
                    :class="{ 'bg-indigo-50 border-l-4 border-l-indigo-500': selectedMediaId === media.id }">
                    <div class="text-sm font-medium text-gray-800 truncate" x-text="media.title || media.id"></div>
                    <div class="mt-1 flex items-center gap-2">
                        <div class="flex-1 bg-gray-200 rounded-full h-2 overflow-hidden">
                            <div class="bg-green-500 h-2 rounded-full" :style="'width:' + (media.total > 0 ? (media.approved / media.total * 100) : 0) + '%'"></div>
                        </div>
                        <span class="text-xs text-gray-500" x-text="media.approved + '/' + media.total"></span>
                    </div>
                </div>
            </template>
            <div x-show="mediaList.length === 0" class="px-4 py-8 text-center text-gray-400 text-sm">
                No media available
            </div>
        </div>
    </div>

    <!-- Sidebar Toggle (when closed) -->
    <button x-show="!sidebarOpen" @click="sidebarOpen = true"
        class="flex-shrink-0 bg-white rounded-lg shadow px-2 py-4 self-start hover:bg-gray-50">
        <svg class="w-4 h-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7"/>
        </svg>
    </button>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col min-w-0 gap-4" x-show="selectedMediaId">

        <!-- Top Bar -->
        <div class="bg-white rounded-lg shadow px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <h2 class="font-semibold text-gray-800 text-sm truncate max-w-md"
                    x-text="currentMediaTitle"></h2>
                <span class="text-xs text-gray-500"
                    x-text="'Segment ' + (currentIndex + 1) + ' / ' + segments.length"></span>
            </div>
            <div class="flex items-center gap-2">
                <select x-model="statusFilter" @change="loadSegments()"
                    class="text-xs border border-gray-300 rounded px-2 py-1">
                    <option value="all">All</option>
                    <option value="needs_review">Needs Review</option>
                    <option value="approved">Approved</option>
                </select>
                <label class="flex items-center gap-1 text-xs text-gray-600">
                    <input type="checkbox" x-model="autoAdvance" class="rounded">
                    Auto-advance
                </label>
                <button @click="showHelp = !showHelp" class="text-gray-400 hover:text-gray-600 text-sm" title="Keyboard shortcuts (?)">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Help Panel -->
        <div x-show="showHelp" x-cloak class="bg-yellow-50 border border-yellow-200 rounded-lg shadow px-4 py-3">
            <div class="flex justify-between items-center mb-2">
                <h3 class="font-semibold text-sm text-yellow-800">Keyboard Shortcuts</h3>
                <button @click="showHelp = false" class="text-yellow-600 hover:text-yellow-800 text-xs">Close</button>
            </div>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs text-yellow-900">
                <div><kbd class="bg-yellow-200 px-1 rounded">Space</kbd> Play/Pause</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">←/→</kbd> Seek 2s</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">Ctrl+←/→</kbd> Seek 5s</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">Tab</kbd> Next segment</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">Shift+Tab</kbd> Prev segment</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">Enter</kbd> Approve current</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">Ctrl+Enter</kbd> Use ASR &amp; approve</div>
                <div><kbd class="bg-yellow-200 px-1 rounded">?</kbd> Toggle help</div>
            </div>
        </div>

        <!-- Waveform -->
        <div class="bg-white rounded-lg shadow px-4 py-3" x-show="currentSegment">
            <div id="waveform" class="w-full h-32 bg-gray-50 rounded"></div>
            <div class="flex items-center gap-4 mt-2">
                <button @click="togglePlay()" class="text-indigo-600 hover:text-indigo-800">
                    <svg x-show="!isPlaying" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/>
                    </svg>
                    <svg x-show="isPlaying" class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M5.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75A.75.75 0 007.25 3h-1.5zM12.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75a.75.75 0 00-.75-.75h-1.5z"/>
                    </svg>
                </button>
                <span class="text-sm text-gray-600" x-text="formatTime(currentTime) + ' / ' + formatTime(currentDuration)"></span>
                <div class="flex items-center gap-1">
                    <label class="text-xs text-gray-500">Speed:</label>
                    <select x-model="playbackRate" @change="setPlaybackRate()" class="text-xs border border-gray-300 rounded px-1 py-0.5">
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1">1.0x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Text Comparison (3 columns) -->
        <div class="bg-white rounded-lg shadow px-4 py-3 flex-1 min-h-0 overflow-y-auto" x-show="currentSegment">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <!-- Original Text -->
                <div>
                    <label class="text-xs font-medium text-gray-500 mb-1 block">Original Text</label>
                    <div class="p-3 bg-gray-50 rounded-lg text-sm text-gray-700 min-h-[80px] whitespace-pre-wrap"
                        x-text="currentSegment?.original_text || '-'"></div>
                </div>

                <!-- Edit Text (editable) -->
                <div>
                    <label class="text-xs font-medium text-gray-500 mb-1 block">
                        Corrected Text
                        <span class="ml-1 text-indigo-500" x-show="liveCer !== null"
                            x-text="'CER: ' + (liveCer * 100).toFixed(1) + '%'"
                            :class="{
                                'text-green-600': liveCer < 0.1,
                                'text-yellow-600': liveCer >= 0.1 && liveCer < 0.15,
                                'text-red-600': liveCer >= 0.15
                            }"></span>
                    </label>
                    <textarea x-ref="editArea"
                        x-model="editText"
                        @input.debounce.300ms="computeLiveCer()"
                        class="w-full p-3 border-2 border-indigo-300 rounded-lg text-sm min-h-[80px] resize-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500"
                        placeholder="Edit transcription..."></textarea>
                </div>

                <!-- ASR Text -->
                <div>
                    <div class="flex items-center justify-between mb-1">
                        <label class="text-xs font-medium text-gray-500">ASR Text</label>
                        <button @click="useAsrText()"
                            class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded hover:bg-green-200 transition"
                            x-show="currentSegment?.whisper_text">
                            Use ASR Text
                        </button>
                    </div>
                    <div class="p-3 bg-green-50 rounded-lg text-sm text-gray-700 min-h-[80px] whitespace-pre-wrap"
                        x-text="currentSegment?.whisper_text || '-'"></div>
                </div>
            </div>

            <!-- Meta info -->
            <div class="mt-3 flex flex-wrap gap-4 text-xs text-gray-500">
                <span>CER: <strong x-text="currentSegment?.cer != null ? ((currentSegment.cer * 100).toFixed(1) + '%') : '-'"></strong></span>
                <span>Duration: <strong x-text="(currentSegment?.duration_sec || 0).toFixed(1) + 's'"></strong></span>
                <span>SNR: <strong x-text="currentSegment?.snr_db ? (currentSegment.snr_db.toFixed(1) + 'dB') : '-'"></strong></span>
                <span>Status: <strong x-text="currentSegment?.status || '-'"
                    :class="{
                        'text-green-600': currentSegment?.status === 'approved',
                        'text-blue-600': currentSegment?.status === 'gpu_pass' || currentSegment?.status === 'exported',
                        'text-red-600': currentSegment?.status?.includes('reject')
                    }"></strong></span>
                <span x-show="currentSegment?.reject_reason">Reject: <strong class="text-red-600" x-text="currentSegment?.reject_reason"></strong></span>
            </div>

            <!-- Actions -->
            <div class="mt-4 flex flex-wrap gap-2">
                <button @click="approveSegment('manual_edit')"
                    class="bg-indigo-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-indigo-700 transition font-medium">
                    Approve (Enter)
                </button>
                <button @click="useAsrAndApprove()"
                    class="bg-green-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-green-700 transition font-medium"
                    x-show="currentSegment?.whisper_text">
                    Use ASR &amp; Approve (Ctrl+Enter)
                </button>
                <button @click="goToSegment(currentIndex + 1)"
                    class="border border-gray-300 text-gray-700 px-4 py-2 rounded-lg text-sm hover:bg-gray-50 transition">
                    Skip (Tab)
                </button>
                <button @click="rejectSegment()"
                    class="border border-red-300 text-red-700 px-4 py-2 rounded-lg text-sm hover:bg-red-50 transition">
                    Reject
                </button>
            </div>
        </div>

        <!-- Empty state -->
        <div x-show="!currentSegment && segments.length === 0 && selectedMediaId"
            class="bg-white rounded-lg shadow px-4 py-12 text-center text-gray-400 flex-1">
            No segments found for this filter.
        </div>

        <!-- Segment Strip (bottom) -->
        <div class="bg-white rounded-lg shadow px-4 py-2" x-show="segments.length > 0">
            <div class="strip-scroll flex gap-1 py-1" x-ref="segmentStrip">
                <template x-for="(seg, idx) in segments" :key="seg.id">
                    <div @click="goToSegment(idx)"
                        class="segment-chip flex-shrink-0"
                        :class="{
                            'bg-green-500': seg.status === 'approved',
                            'bg-blue-500': seg.status === 'gpu_pass' || seg.status === 'exported',
                            'bg-red-400': seg.status?.includes('reject'),
                            'bg-gray-400': !['approved','gpu_pass','exported'].includes(seg.status) && !seg.status?.includes('reject'),
                            'active': idx === currentIndex
                        }"
                        :title="'#' + (idx+1) + ' ' + seg.status"
                        x-text="idx + 1">
                    </div>
                </template>
            </div>
        </div>
    </div>

    <!-- No media selected state -->
    <div x-show="!selectedMediaId" class="flex-1 flex items-center justify-center">
        <div class="text-center text-gray-400">
            <svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
            </svg>
            <p class="text-lg">Select a media from the sidebar to begin</p>
            <p class="text-sm mt-1">Review and correct transcriptions</p>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js';
window.WaveSurfer = WaveSurfer;
</script>
<script>
function transcribePage() {
    return {
        // Media
        mediaList: [],
        selectedMediaId: null,
        sidebarOpen: true,

        // Segments
        segments: [],
        currentIndex: 0,
        statusFilter: 'all',

        // Edit state
        editText: '',
        liveCer: null,
        isPlaying: false,
        playbackRate: 1,
        currentTime: 0,
        currentDuration: 0,

        // wavesurfer
        wavesurfer: null,

        // Settings
        autoAdvance: true,
        showHelp: false,

        // Saving state
        _saving: false,

        get currentSegment() {
            return this.segments[this.currentIndex] || null;
        },

        get currentMediaTitle() {
            const media = this.mediaList.find(m => m.id === this.selectedMediaId);
            return media ? (media.title || media.id) : '';
        },

        async init() {
            await this.loadMediaList();

            // Check URL params
            const params = new URLSearchParams(window.location.search);
            const mediaId = params.get('media_id');
            const segmentId = params.get('segment_id');

            if (mediaId) {
                await this.selectMedia(mediaId);
                if (segmentId) {
                    const idx = this.segments.findIndex(s => s.id === segmentId);
                    if (idx >= 0) this.goToSegment(idx);
                }
            }
        },

        async loadMediaList() {
            try {
                const resp = await fetch('/api/dashboard/transcribe/media');
                this.mediaList = await resp.json();
            } catch (e) {
                console.error('Failed to load media list:', e);
            }
        },

        async selectMedia(mediaId) {
            this.selectedMediaId = mediaId;
            this.currentIndex = 0;
            await this.loadSegments();
            if (this.segments.length > 0) {
                this.goToSegment(0);
            }
        },

        async loadSegments() {
            if (!this.selectedMediaId) return;
            try {
                const resp = await fetch(`/api/dashboard/transcribe/segments/${this.selectedMediaId}?status_filter=${this.statusFilter}`);
                this.segments = await resp.json();
                if (this.currentIndex >= this.segments.length) {
                    this.currentIndex = Math.max(0, this.segments.length - 1);
                }
            } catch (e) {
                console.error('Failed to load segments:', e);
            }
        },

        goToSegment(idx) {
            if (idx < 0 || idx >= this.segments.length) return;
            this.currentIndex = idx;
            const seg = this.currentSegment;
            if (!seg) return;

            this.editText = seg.normalized_text || seg.original_text || '';
            this.computeLiveCer();
            this.loadWaveform(seg.id);
            this.updateUrl();
            this.scrollStripToView();
        },

        loadWaveform(segId) {
            const url = `/api/dashboard/segments/${segId}/audio`;

            if (this.wavesurfer) {
                this.wavesurfer.destroy();
                this.wavesurfer = null;
            }

            this.isPlaying = false;
            this.currentTime = 0;
            this.currentDuration = 0;

            if (!window.WaveSurfer) {
                console.warn('WaveSurfer not loaded yet');
                return;
            }

            this.wavesurfer = window.WaveSurfer.create({
                container: '#waveform',
                waveColor: '#c7d2fe',
                progressColor: '#4f46e5',
                height: 128,
                barWidth: 2,
                barGap: 1,
                barRadius: 2,
                cursorColor: '#6366f1',
                cursorWidth: 2,
                url: url,
            });

            this.wavesurfer.on('ready', () => {
                this.currentDuration = this.wavesurfer.getDuration();
                this.wavesurfer.setPlaybackRate(parseFloat(this.playbackRate));
            });

            this.wavesurfer.on('timeupdate', (time) => {
                this.currentTime = time;
            });

            this.wavesurfer.on('finish', () => {
                this.isPlaying = false;
            });

            this.wavesurfer.on('play', () => { this.isPlaying = true; });
            this.wavesurfer.on('pause', () => { this.isPlaying = false; });
        },

        togglePlay() {
            if (!this.wavesurfer) return;
            this.wavesurfer.playPause();
        },

        seek(seconds) {
            if (!this.wavesurfer) return;
            const dur = this.wavesurfer.getDuration();
            if (dur <= 0) return;
            const newTime = Math.max(0, Math.min(dur, this.wavesurfer.getCurrentTime() + seconds));
            this.wavesurfer.seekTo(newTime / dur);
        },

        setPlaybackRate() {
            if (this.wavesurfer) {
                this.wavesurfer.setPlaybackRate(parseFloat(this.playbackRate));
            }
        },

        formatTime(sec) {
            if (!sec || isNaN(sec)) return '0:00';
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return m + ':' + s.toString().padStart(2, '0');
        },

        // CER computation (JS mirror of Python)
        normalizeForCer(text) {
            if (!text) return '';
            return text.normalize('NFC').replace(/\s/g, '').toLowerCase();
        },

        levenshteinDistance(s1, s2) {
            if (s1.length < s2.length) return this.levenshteinDistance(s2, s1);
            if (s2.length === 0) return s1.length;
            let prev = Array.from({ length: s2.length + 1 }, (_, i) => i);
            for (let i = 0; i < s1.length; i++) {
                const curr = [i + 1];
                for (let j = 0; j < s2.length; j++) {
                    const ins = prev[j + 1] + 1;
                    const del = curr[j] + 1;
                    const sub = prev[j] + (s1[i] !== s2[j] ? 1 : 0);
                    curr.push(Math.min(ins, del, sub));
                }
                prev = curr;
            }
            return prev[prev.length - 1];
        },

        computeLiveCer() {
            const seg = this.currentSegment;
            if (!seg || !seg.whisper_text) { this.liveCer = null; return; }
            const ref = this.normalizeForCer(this.editText);
            const hyp = this.normalizeForCer(seg.whisper_text);
            if (!ref.length) { this.liveCer = hyp.length > 0 ? 1.0 : 0.0; return; }
            this.liveCer = this.levenshteinDistance(ref, hyp) / ref.length;
        },

        useAsrText() {
            const seg = this.currentSegment;
            if (!seg || !seg.whisper_text) return;
            this.editText = seg.whisper_text;
            this.computeLiveCer();
        },

        async useAsrAndApprove() {
            this.useAsrText();
            await this.approveSegment('use_asr');
        },

        async approveSegment(source) {
            const seg = this.currentSegment;
            if (!seg || this._saving) return;
            this._saving = true;

            try {
                const resp = await fetch(`/api/dashboard/transcribe/segments/${seg.id}/approve`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        normalized_text: this.editText,
                        source: source || 'manual_edit',
                    }),
                });

                if (!resp.ok) {
                    console.error('Approve failed:', await resp.text());
                    return;
                }

                const result = await resp.json();

                // Update local state
                seg.status = 'approved';
                seg.normalized_text = result.normalized_text;
                seg.cer = result.cer;

                // Update media list counts
                await this.loadMediaList();

                // Auto-advance
                if (this.autoAdvance && this.currentIndex < this.segments.length - 1) {
                    this.goToSegment(this.currentIndex + 1);
                }
            } catch (e) {
                console.error('Error approving:', e);
            } finally {
                this._saving = false;
            }
        },

        async rejectSegment() {
            const seg = this.currentSegment;
            if (!seg || this._saving) return;

            const reason = prompt('Reject reason:', 'unintelligible');
            if (reason === null) return;

            this._saving = true;
            try {
                const resp = await fetch(`/api/dashboard/transcribe/segments/${seg.id}/reject`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reason: reason || 'unintelligible' }),
                });

                if (!resp.ok) {
                    console.error('Reject failed:', await resp.text());
                    return;
                }

                seg.status = 'gpu_reject';
                seg.reject_reason = `manual_review:${reason}`;

                await this.loadMediaList();

                if (this.autoAdvance && this.currentIndex < this.segments.length - 1) {
                    this.goToSegment(this.currentIndex + 1);
                }
            } catch (e) {
                console.error('Error rejecting:', e);
            } finally {
                this._saving = false;
            }
        },

        updateUrl() {
            const seg = this.currentSegment;
            if (!seg) return;
            const url = `/transcribe?media_id=${this.selectedMediaId}&segment_id=${seg.id}`;
            history.replaceState(null, '', url);
        },

        scrollStripToView() {
            this.$nextTick(() => {
                const strip = this.$refs.segmentStrip;
                if (!strip) return;
                const chips = strip.children;
                if (chips[this.currentIndex]) {
                    chips[this.currentIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            });
        },

        handleKeydown(e) {
            const tag = e.target.tagName;
            const inTextarea = tag === 'TEXTAREA' || tag === 'INPUT';

            // Always active shortcuts
            if (e.key === 'Escape') {
                this.showHelp = false;
                e.preventDefault();
                return;
            }

            if (e.key === 'Tab') {
                e.preventDefault();
                if (e.shiftKey) {
                    this.goToSegment(this.currentIndex - 1);
                } else {
                    this.goToSegment(this.currentIndex + 1);
                }
                return;
            }

            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                this.useAsrAndApprove();
                return;
            }

            // Shortcuts that don't work inside textarea
            if (inTextarea) return;

            if (e.key === ' ') {
                e.preventDefault();
                this.togglePlay();
                return;
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                this.seek(e.ctrlKey ? -5 : -2);
                return;
            }

            if (e.key === 'ArrowRight') {
                e.preventDefault();
                this.seek(e.ctrlKey ? 5 : 2);
                return;
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                this.approveSegment('manual_edit');
                return;
            }

            if (e.key === '?') {
                e.preventDefault();
                this.showHelp = !this.showHelp;
                return;
            }
        },
    };
}
</script>
{% endblock %}
